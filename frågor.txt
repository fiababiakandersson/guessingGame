Jag siktar på VG!

- Vad är pull repektive push?
    "pull" är kommandot vi använder för att "dra ner" ändringar från ett remote repository till vårt lokala repository. Kommandot "push" skickar din commit till det remote repositoryt. 

- När använder man log respektive status?
    Kommandot "git status" ger oss information om branchen som vi jobbar på. "git status" ger oss dock ingen information om våran commit historik. Då kan vi istället använda "git log" som ger oss information om hela commit historiken för din branch.

- Vad är en Git branch och varför är de viktiga?
    En Git-branch är som en separat kopia/version av projektet där du kan göra ändringar utan att påverka den fungerande huvudkoden.
    Git branches hjälper oss att arbeta på olika versioner av våran kod samtidigt. Branches är otroligt viktiga eftersom de gör att vi kan arbeta och testa på flera saker samtidigt utan att riskera kodbasen vilket ökar både säkerheten och flexibiliteten i utvecklingen.

- Det finns flera sätt att rulla tillbaka koden till ett tidigare tillstånd. Förklara skillnaden och motivera när man skulle använda den ena eller andra metoden. Ge exempel på de kommandon du använder för att göra detta och vissa att det fungerar, vilken output du fick från git-kommandona.
    Detta är de vanligaste Git kommandon för att återställa kod: git reset, git revert och git restore.

    "git reset" används för att återställa kod genom att flytta den senaste commiten till en tidigare commit. "git reset" kan användas på tre olika sätt. Det första är --soft, som behåller alla filer i staging-området men flyttar tillbaka HEAD till tidigare commit. Den andra är --mixed (standard) som också flyttar tillbaka HEAD, men behåller filer i arbetskatalogen istället för i staging-området. Det sista sättet är --hard som, de tidigare sätten, flyttar HEAD till en tidigare commit men till skillnad från de tidigare sätten så tar --hard bort alla ändringarna permanent. Därför bör man använda "git reset --hard" med försiktighet. I bilden ResetExample.png kan man se hur resultatet kan bli av en "git reset --mixed". I det här fallet väljer jag att backa tillbaka en tidigare commit med "HEAD~1", och vi ser i terminalen att vi har fått "unstaged changes" i testFile.txt. Ändringarna är "unstaged" eftersom vi valt flaggan "--mixed". Om man kollar en bit ovanför terminalen, så ser man de faktiska ändringarna med en före och efter, som vi sedan kan commita.

    Det andra kommandot är "git revert". Detta kommando tar ändringarna från den tidigare commiten och skapar en ny commit med dessa ändringar. Detta sätt att återställa kod är säkrare än "git reset" och bra att använda när man arbetar i ett delat projekt, då det inte tar bort historik. Se bild RevertExample.png på hur en output kan se ut efter man använt "git revert".
    Här ser vi exakt vilken commit som vi valt att reverta och vilka ändringar som hänt i våran revert.

    Det sista exemplet på kommandon för att återställa kod är "git restore". Detta kommando använder vi när vi vill återställa ändringar på filnivå eller i arbetskatalogen, vilket är användbart när vi vill gå tillbaka till tidigare versioner av filer i projektet. "git restore" har ingen effekt på historiken. I bilden RestoreExample.png kan man se hur resultatet kan bli på en fil efter att vi använt "git restore". Generellt ger "git restore" ingen output tillbaka i terminalen om allting gick bra. Men vi kan istället se i bilden, ovanför terminalen, att vi fått en skillnad i filen.

-Beskriv och jämför hur man kan använda git rebase och git merge i ett scenario där flera utvecklare jobbar på olika feature branches. Diskutera fördelarna och nackdelarna med båda teknikerna, samt hur de påverkar historiken.
    När flera utvecklare jobbar på olika feature branches så finns det två tekniker som främst används för att integrera deras arbete in i main/master: "git merge" och "git rebase". 

    "git merge" är en teknik för att integrera två branches inom ett Git repository. Denna teknik behåller branchens historik och förändringar, vilket är värdefullt för utvecklarna för att förstå hur och när förändringar har genomförts. Nackdelen med detta kan bli att historiken påverkas, blir komplex och svår att följa eftersom "git merge" lägger till merge-commits.

    "git rebase" är en teknik för att flytta commits till en ny bas, vilket kan vara fördelaktigt att använda när man arbetar flera utvecklare på samma projekt. Fördelen med rebase är att den resulterar i en "renare" historik som är lättare att följa, vilket i sin tur kan göra det lättare att hitta ock återställa buggar. Detta kan självklart vara en fördel när flera utvecklare arbetar på samma projekt. En nackdel med "git rebase" är att det kan leda till upprepade konflikter som måste lösas vid varje commit, vilket leder till mer arbete och tid. "git rebase" kan också vara svårare för utvecklare som är mindre erfarna. Precis som "git merge" så påverkar även "git rebase" historiken genom att flytta commits till en ny bas och ge de nya IDn.

-Uppgift: Skapa ett repo med två eller fler feature branches som utvecklare arbetar på. Beskriv hur du löser konflikter som uppstår under rebase och merge och visa slutresultatet i historik.
    Merge konflikt = I mitt repo så skapade jag en java-klass som heter MergeTest där jag skapade en System.out.println metod. Sedan skapade jag två feature branches: merge och merge2. Båda baserat på main-branchen. I merge-branchen så gjorde jag en ändring i min metod och sedan mergade detta med main, så att main nu är uppdaterad med dessa ändringar. Sedan bytte jag branch till merge2-branchen och gjorde ändringar på exakt samma rad som jag gjorde ändringarna i merge-branchen. Efter dessa ändringar var staged och commitade, så körde jag kommandot "git pull origin main" för att uppdatera denna feature branch. Detta orsakade då en merge-konflikt (som man kan se i bilden MergeConflict.png). Eftersom jag ville ha mina senaste ändringar så klickade jag på knappen "Accept Current Change" (inringat i rosa) så att jag behåller mina senaste ändringar, och den gamla versionen försvinner. Nu när merge-konflikten är resolved så kan jag commita detta, och min merge är färdig. 

    Rebase konflikt = Jag skapade en ny fil som jag nämnde RebaseTest. Sedan skapade jag två feature branches: rebase och rebase2 som är baserade på main branchen. I min branch "rebase" så gjorde jag ändringar, och mergade dessa ändringar med main så att main branchen nu är uppdaterad. Sedan bytte jag branch till "rebase2". Här gjorde jag nu också ändringar på exakt samma rad som jag gjorde i min rebase-branch. Efter att dessa ändringar var commitade så bytte jag till main-branchen och körde kommandot "git rebase rebase2", vilket då ger mig en konflikt (se bild RebaseConflict.png). Precis som i mitt merge-exempel ovan så ville jag behålla mina senaste ändringar och klickade på knappen "Accept Current Change" (inringat i rosa). Nu kan jag commita detta, och min rebase är färdig. 

